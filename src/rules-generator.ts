/**
 * Rules Generator - Generate persistent strategy instructions
 *
 * Creates .claudecode.instructions.md with token optimization rules
 * that Claude Code will follow in all sessions.
 */

import * as fs from "fs";
import * as path from "path";

export interface RulesConfig {
  strictMode: boolean;
  autoCheckpoint: boolean;
  surgeonDefault: boolean;
  maxFileReadLines: number;
  budgetWarningThreshold: number;
}

const DEFAULT_CONFIG: RulesConfig = {
  strictMode: true,
  autoCheckpoint: true,
  surgeonDefault: true,
  maxFileReadLines: 150,
  budgetWarningThreshold: 60,
};

/**
 * Generate rules file content
 */
export function generateRulesContent(config: RulesConfig = DEFAULT_CONFIG): string {
  return `# Claude Code Strategy Instructions

> Auto-generated by \`rag:rules\`. These instructions optimize token consumption.

## üéØ Core Principles

1. **Signature-First Reading**: Never read a full file if AST signatures suffice
2. **Checkpoint Recovery**: Always check \`.claude/last_checkpoint.md\` after \`/new\`
3. **Ultra-Concise Responses**: Minimize confirmation messages

## ‚ö° Mandatory Token Optimization Rules

### File Reading Strategy
- **NEVER** read files > ${config.maxFileReadLines} lines without explicit justification
- **ALWAYS** use \`--surgeon\` mode for initial exploration
- **PREFER** \`rag:expand <path:line>\` over full file reads
- **USE** \`--types-only\` or \`--signatures-only\` flags first

### Session Management
- **CHECK** \`.claude/last_checkpoint.md\` at session start
- **RUN** \`pnpm rag:checkpoint\` before long breaks or context switches
- **MONITOR** budget with \`pnpm rag:budget\` every ~10 actions

### Context Efficiency
- **DECLARE** \`rag:context-lock\` when sufficient context is gathered
- **USE** \`rag:hypothesis\` for complex debugging tasks
- **AVOID** reading the same file multiple times

## üö® Budget Alerts

When budget exceeds ${config.budgetWarningThreshold}%:
1. Stop non-essential reads immediately
2. Run \`pnpm rag:checkpoint\`
3. Consider starting fresh with \`/new\`

## üìã Response Format Rules

### Confirmations
‚ùå "I've successfully completed the task and updated the file."
‚úÖ "Done."

### Explanations
‚ùå Long paragraphs explaining every change
‚úÖ Bullet points with changed files only

### Questions
‚ùå "Would you like me to proceed with implementing this feature?"
‚úÖ "Proceed? (y/n)"

## üîß Tool Usage Priority

| Priority | Tool | When to Use |
|----------|------|-------------|
| 1 | \`rag:context --surgeon\` | Initial exploration |
| 2 | \`rag:expand\` | Load specific lines |
| 3 | \`rag:deps --impact\` | Before refactoring |
| 4 | \`Read\` (offset/limit) | Last resort |

## üîÑ Session Flow

\`\`\`
Session Start
    ‚îÇ
    ‚îú‚îÄ‚Üí Check .claude/last_checkpoint.md
    ‚îÇ
    ‚îú‚îÄ‚Üí Load context with --surgeon mode
    ‚îÇ
    ‚îú‚îÄ‚Üí Work (monitor budget)
    ‚îÇ
    ‚îú‚îÄ‚Üí Budget > ${config.budgetWarningThreshold}%? ‚Üí rag:checkpoint
    ‚îÇ
    ‚îî‚îÄ‚Üí Session End ‚Üí Auto-checkpoint
\`\`\`

## ‚õî Absolute Prohibitions

1. **NEVER** use \`Read\` without prior \`rag:context\` search
2. **NEVER** ignore budget warnings
3. **NEVER** read full files for "context" without specific need
4. **NEVER** use verbose confirmation messages
5. **NEVER** forget to check checkpoint after \`/new\`

---
*Generated: ${new Date().toISOString()}*
*Config: strictMode=${config.strictMode}, surgeonDefault=${config.surgeonDefault}*
`;
}

/**
 * Generate rules file
 */
export function generateRulesFile(
  rootDir: string,
  config: RulesConfig = DEFAULT_CONFIG
): string {
  const content = generateRulesContent(config);
  const filePath = path.join(rootDir, ".claudecode.instructions.md");
  fs.writeFileSync(filePath, content);
  return filePath;
}

/**
 * Load existing rules config
 */
export function loadRulesConfig(rootDir: string): RulesConfig | null {
  const filePath = path.join(rootDir, ".claudecode.instructions.md");
  if (!fs.existsSync(filePath)) return null;

  try {
    const content = fs.readFileSync(filePath, "utf-8");
    const configMatch = content.match(/Config: strictMode=(\w+), surgeonDefault=(\w+)/);

    if (configMatch) {
      return {
        ...DEFAULT_CONFIG,
        strictMode: configMatch[1] === "true",
        surgeonDefault: configMatch[2] === "true",
      };
    }
  } catch { /* ignore parse errors */ }

  return null;
}

/**
 * Update rules file with new config
 */
export function updateRulesFile(
  rootDir: string,
  updates: Partial<RulesConfig>
): string {
  const existing = loadRulesConfig(rootDir) || DEFAULT_CONFIG;
  const newConfig = { ...existing, ...updates };
  return generateRulesFile(rootDir, newConfig);
}

/**
 * Format rules summary for CLI
 */
export function formatRulesSummary(config: RulesConfig): string {
  return `
üìú Claude Code Strategy Rules

Configuration:
  ‚Ä¢ Strict Mode: ${config.strictMode ? "‚úÖ Enabled" : "‚ùå Disabled"}
  ‚Ä¢ Surgeon Default: ${config.surgeonDefault ? "‚úÖ Enabled" : "‚ùå Disabled"}
  ‚Ä¢ Auto Checkpoint: ${config.autoCheckpoint ? "‚úÖ Enabled" : "‚ùå Disabled"}
  ‚Ä¢ Max File Lines: ${config.maxFileReadLines}
  ‚Ä¢ Warning Threshold: ${config.budgetWarningThreshold}%

Key Rules:
  1. Use AST signatures before full reads
  2. Check last_checkpoint.md after /new
  3. Ultra-concise responses only
  4. Monitor budget every ~10 actions

File: .claudecode.instructions.md
`;
}

/**
 * Check if rules are followed (for hooks)
 */
export function validateRulesCompliance(
  rootDir: string,
  action: { type: string; target?: string; lines?: number }
): { compliant: boolean; warning?: string } {
  const config = loadRulesConfig(rootDir) || DEFAULT_CONFIG;

  if (action.type === "read" && action.lines && action.lines > config.maxFileReadLines) {
    return {
      compliant: false,
      warning: `‚ö†Ô∏è Reading ${action.lines} lines exceeds limit (${config.maxFileReadLines}). Use rag:expand or offset/limit.`,
    };
  }

  return { compliant: true };
}
